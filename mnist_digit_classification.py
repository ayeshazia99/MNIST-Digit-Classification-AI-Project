# -*- coding: utf-8 -*-
"""MNIST_Digit_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ywuVLy1esWVrc-AsMUc1Y4_F3Oislb6v

###**MINIST Handwritten Digit Classification using Deep Learning (Neural Network)**

Importing the Dependencies
"""

import numpy as np    #use to convert image data into numpy arrays
import matplotlib.pyplot as plt            #use to visualize the images in the dataset
import seaborn as sns          #use to plot the image
import cv2        #opencv library where cv is computer vision and used in image recognition tasks
from google.colab.patches import cv2_imshow       #function of cv2 used to show the image
from PIL import Image      #image processing library
#below all are deep learning libraries
import tensorflow as tf        #developed by google
tf.random.set_seed(3)                #setting some random seed value for tensorflow
from tensorflow import keras     #used to create neural network
from keras.datasets import mnist        #importing mnist dataset available in keras library
from tensorflow.math import confusion_matrix

"""Loading the MNIST data from Keras.datasets"""

#we are working on greyscale images
(X_train, Y_train), (X_test, Y_test) = mnist.load_data()      #dividing the datasets into training and testing data

#displaying type of the arrays
type(X_train)

#shape of the numpy arrays
print(X_train.shape)            #show the count of images in the training datasdet and the dimension of images
print(Y_train.shape)           #show the labels of images in training datasets
print(X_test.shape)           #show the count of images in testing datasets and the dimension of images
print(Y_test.shape)          #show the labels of images in testing datasets

"""Training Data = 60,000 images

Testing Data = 10,000 images


Image Dimension --> 28 x 28

Grayscale Images --> 1 color channel

"""

#printing the 10th image
print(X_train[10])         #image is converted to numpy array where values ranges from 0-255

#displaying teh image at index 60
plt.imshow(X_train[60])
plt.show()

#displaying the label of the image 
print("LABEL = ", Y_train[60])

"""Image Labels"""

print(Y_train.shape, Y_test.shape)

#finding out unique values of labels in Y_train
print(np.unique(Y_train))

#finsing out unique values of labels in Y_test
print(np.unique(Y_test))

"""we can use these labels as such or can also use One Hot Encoding

All the images have the same dimenion in this dataset. If not, we have to resize all the images to a common dimension using padding.
"""

#scaling the values
#converting the range of 0-255 to 0-1 so that it will be easy for neural network to understand the data
X_train = X_train/255
X_test = X_test/255

#printing the 10th image

print(X_train[10])

"""Building the Neural Network"""

# setting up layers of Neural Network

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28,28)),
    keras.layers.Dense(50, activation='relu'),
    keras.layers.Dense(50, activation='relu'),
    keras.layers.Dense(10, activation='sigmoid')
])

#compiling the neural network

model.compile(optimizer='adam', #reserach for diff optimizer change it to check accuracy
              loss='sparse_categorical_crossentropy', #for one hot encoding
              metrics=['accuracy']) #no correct predictions/total no of datapoints

# Training the Neural Network
history = model.fit(X_train,Y_train,epochs=10)

#Training the Neural Network

model.fit(X_train,Y_train,epochs=10) #all values will be between 0-1 and epoch=10(no of times neural network will go through data)

"""Training data accuracy is 98.9%

**Accuracy on Test Data**
"""

loss,accuracy=model.evaluate(X_test,Y_test)
print(accuracy)

"""Test data accuracy is 97.1%"""

# Plotting the accuracy graph
plt.plot(history.history['accuracy'])
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.show()

print(X_test.shape)

#first data point in X_test
plt.imshow(X_test[0])
plt.show()

print(Y_test[0])

Y_pred=model.predict(X_test)

print(Y_pred.shape)

print(Y_pred[0])

"""model.predict() gives the prediction probability of each class(0-9) for the particular data """

#converting the prediction probability to labels

label_for_first_test_image = np.argmax(Y_pred[0])
print(label_for_first_test_image)  #value in 7th index is heighest

#converting the prediction probabilities to class labels for all data points
Y_pred_labels=[np.argmax(i) for i in Y_pred]
print(Y_pred_labels)

"""Y_test --> True labels

Y_pred_labels --> Predicted Labels

Confusion Matrix
"""

#using the confusion_matrix imported above from tensor flow
conf_mat= confusion_matrix(Y_test, Y_pred_labels) #taking the true and predicted values in array

from google.colab import drive
drive.mount('/content/drive')

print(conf_mat)

#we will use the above values to build the heatmap
plt.figure(figsize=(15,7)) #defining the size of plot
sns.heatmap(conf_mat,annot=True,fmt='d',cmap='Blues') #defining that all values should be in integer through fmt
plt.ylabel('True Labels')
plt.xlabel('Predicated Labels')

"""Building a Predictive System"""

input_image_path='/content/drive/MyDrive/MNIST Digits/MNIST_digit.png'
#converting the image into numpy array after reading it 
input_image=cv2.imread(input_image_path) #the function takes path of image as argument

#checking type of input image 
type(input_image)

print(input_image)
#0 means black and ... means there are several values in between

#display image from numpy array
cv2_imshow(input_image)

#checking shape of image 
input_image.shape

#the image is read as a RGB image by cv2_imshow

#we have to convert the image to grayscale
grayscale=cv2.cvtColor(input_image,cv2.COLOR_RGB2GRAY)

grayscale.shape
#the image is now grayscale

#now we will resize the image
input_image_resize=cv2.resize(grayscale, (28,28))

#now we will check the size again
input_image_resize.shape

cv2_imshow(input_image_resize)

#scaling the values here again that we did for training data
input_image_resize=input_image_resize/255

#reshaping the image to tell the NN model that we're predicting for 1 image
#we're reshaping the numpy array
image_reshaped=np.reshape(input_image_resize,[1,28,28])

#we will now use the model to predict
input_prediction=model.predict(image_reshaped)
print(input_prediction)

#finding the labels
input_pred_label=np.argmax(input_prediction)

print(input_pred_label)

"""**Predictive System**"""

input_image_path=input('Enter the path of the image to be predicted: ')

input_image=cv2.imread(input_image_path)

cv2_imshow(input_image)

grayscale=cv2.cvtColor(input_image,cv2.COLOR_RGB2GRAY)

input_image_resize=cv2.resize(grayscale, (28,28))

input_image_resize=input_image_resize/255

image_reshaped=np.reshape(input_image_resize,[1,28,28])

input_prediction=model.predict(image_reshaped)

input_pred_label=np.argmax(input_prediction)

print('The Handwritten Digit In Image Is Reconginized As: ',input_pred_label)